<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no"/>
  <title>Git</title>
  <link href="http://example.org//css/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"/>
  <link href="http://example.org//css/style.css" type="text/css" rel="stylesheet" media="screen,projection"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/default.min.css">
  <style type="text/css">
  
    footer.page-footer{background-image: url(http://example.org//images/default.png);}
  
  </style>
</head>
<body>
  <ul id="slide-out" class="side-nav">
    <li><a href="http://example.org/"><i class="mdi-action-home left"></i>Home<i class="mdi-hardware-keyboard-arrow-right right"></i></a></li>
    <li><a href="http://example.org//categories"><i class="mdi-action-perm-media left"></i>Categories<i class="mdi-hardware-keyboard-arrow-right right"></i></a></li>
    <li><a href="http://example.org//tags"><i class="mdi-action-loyalty left"></i>Tags<i class="mdi-hardware-keyboard-arrow-right right"></i></a></li>
  </ul>
  <div id="index-banner" class="parallax-container">
  <a data-activates="slide-out" class="btn-floating button-collapse" style="top: 5px; left: 5px;"><i class="mdi-navigation-menu"></i></a>
    <div class="section no-pad-bot">
      <div class="container">
        
        <h1 class="header center teal-text text-lighten-2">My New Hugo Site</h1>
        <div class="row center">
          <h5 class="header col s12 light"></h5>
        </div>
        <div class="row center">
        
        
        
        
        
        
          <a href="http://example.org//index.xml"><img src="http://example.org//images/feed-dreamstale27.png"></a>
        </div>
      </div>
    </div>
    <div class="parallax">
    
      <img src="http://example.org//images/default.png">
    
    </div>
  </div>



<div class="container">
  <div class="section">

    <div class="row">
      <div class="col s12">
        <div class="card-panel">
          <h4>Git</h4>
          <p>
           
          </p>
          <p><h1 id="git学习">Git学习</h1>
<p>[toc]</p>
<h2 id="一git简介">一、Git简介</h2>
<h3 id="11-git诞生">1.1 Git诞生</h3>
<p>作者：Linus
原因：BitMover公司要收回Linux社区免费使用BitKeeper的权利（Linux社区有人想破解BitKeeper，被BitMover发现了）
时间：2005年，2周时间写出来的
代码：C语言</p>
<h3 id="12-集中式vs分布式">1.2 集中式vs分布式</h3>
<table>
<thead>
<tr>
<th>模式</th>
<th>代表</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>集中式</td>
<td>CVS、SVN</td>
<td>1、必须中央服务器<!-- raw HTML omitted -->2、必须联网才能使用<!-- raw HTML omitted -->3、中央服务器挂了，大家都歇了</td>
</tr>
<tr>
<td>分布式</td>
<td>Git、BitKeeper、Bazaar</td>
<td>1、无中央服务器<!-- raw HTML omitted -->2、每台电脑都是完整仓库<!-- raw HTML omitted -->3、互相推送各自改动的内容<!-- raw HTML omitted -->4、互为备份，避免丢失</td>
</tr>
</tbody>
</table>
<h2 id="二git安装">二、Git安装</h2>
<h3 id="21-linux版本安装">2.1 Linux版本安装</h3>
<ul>
<li>查看是否已经安装</li>
</ul>
<p>可以尝试输入 <em><strong><code>git</code></strong></em>，查看是否已经安装了</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$git
The program <span style="color:#e6db74">&#39;git&#39;</span> is currently not installed. You can install it by typing:
sudo apt-get install git
</code></pre></div><p>像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。</p>
<ul>
<li>Debian或Ubuntu Linux版本</li>
</ul>
<p>如果你碰巧用Debian或Ubuntu Linux，通过一条</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">sudo apt-get install git
</code></pre></div><p>就可以直接完成Git的安装，非常简单。</p>
<p>老一点的Debian或Ubuntu Linux，要把命令改为</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">sudo apt-get install git-core
</code></pre></div><p>因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫&quot;git-core&quot;了。由于Git名气实在太大，后来就把GNU Interactive Tools改成&quot;gnuit&quot;，&ldquo;git-core&quot;正式改为&quot;git&rdquo;。</p>
<ul>
<li>源码安装</li>
</ul>
<p>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入以下命令就好了：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$./config
$make
$sudo make install
</code></pre></div><h3 id="22-windows版本安装git-config">2.2 Windows版本安装（git config）</h3>
<ul>
<li>安装</li>
</ul>
<p>在Windows上使用Git，可以从Git官网直接下载安装程序，然后按默认选项安装即可。</p>
<p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p>
<ul>
<li>配置</li>
</ul>
<p>安装完成后，还需要最后一步设置，在命令行输入以下两行命令：
git config &ndash;global user.name &ldquo;Your Name&rdquo;
git config &ndash;global user.email &ldquo;<a href="mailto:email@example.com">email@example.com</a>&rdquo;</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git config --global user.name <span style="color:#e6db74">&#34;Liujx&#34;</span>

$ git config --global user.email <span style="color:#e6db74">&#34;liujixia0410@163.com&#34;</span>
</code></pre></div><p>注意git config命令的&ndash;global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<p>另，以上内容记录在&quot;.gitconfig&quot;文件中。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /c/Users/lenovo/.gitconfig
<span style="color:#f92672">[</span>user<span style="color:#f92672">]</span>
        name <span style="color:#f92672">=</span> Liujx
        email <span style="color:#f92672">=</span> liujixia0410@163.com
<span style="color:#f92672">[</span>gui<span style="color:#f92672">]</span>
        recentrepo <span style="color:#f92672">=</span> Z:/Git/learngit
</code></pre></div><h2 id="三版本库repository管理">三、版本库repository管理</h2>
<h3 id="31-创建版本库git-init命令">3.1 创建版本库（git init命令）</h3>
<p>可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<ul>
<li>1、建一个新目录（我起名learngit）</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$cd /z/Git
$mkdir learngit
$cd learngit
$pwd
/z/Git/learngit
</code></pre></div><ul>
<li>2、通过 <em><strong><code>git init</code></strong></em> 命令把这个目录变成Git可以管理的仓库</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$cd /z/Git/learngit
$git init
Initialized empty Git repository in Z:/Git/learngit/.git/
</code></pre></div><p>Git仓库建好了，而且是一个空的仓库（empty Git repository）.
当前目录（/z/Git/learngit）下多了一个<!-- raw HTML omitted -->.git<!-- raw HTML omitted -->的目录（隐藏目录），是Git跟踪管理版本库的，<!-- raw HTML omitted -->千万不能动<!-- raw HTML omitted -->。</p>
<h3 id="32-版本管理">3.2 版本管理</h3>
<h4 id="321-git-add--git-commit">3.2.1 git add &amp; git commit</h4>
<p>将学习笔记《Git_Learn_Note.md》放到版本控制目录下，即&quot;/z/Git/learngit&quot;下面，子目录也行
<!-- raw HTML omitted -->我建了子目录，实际放在&quot;/z/Git/learngit/git_learn_notes&quot;<!-- raw HTML omitted --></p>
<ul>
<li><em><strong>git add</strong></em>
第一步，使用 <em><strong><code>git add</code></strong></em> 命令，把文件添加到Git仓库
这步执行之后，是没有任何提示的</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$git add Git_Learn_Note.md
</code></pre></div><ul>
<li><em><strong>git commit</strong></em>
第二步，使用 <em><strong><code>git commit</code></strong></em> 命令，把文件提交到Git仓库</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git commit -m <span style="color:#e6db74">&#34;First Git Learn, it&#39;s my git learning note.&#34;</span>
<span style="color:#f92672">[</span>master <span style="color:#f92672">(</span>root-commit<span style="color:#f92672">)</span> d8ca75e<span style="color:#f92672">]</span> First Git Learn, it<span style="color:#960050;background-color:#1e0010">&#39;</span>s my git learning note.
 <span style="color:#ae81ff">1</span> file changed, <span style="color:#ae81ff">108</span> insertions<span style="color:#f92672">(</span>+<span style="color:#f92672">)</span>
 create mode <span style="color:#ae81ff">100644</span> git_learn_notes/Git_Learn_Note.md
</code></pre></div><p><em><strong><!-- raw HTML omitted -->&ldquo;git add &amp; git commit&quot;说明：</strong></em></p>
<ul>
<li><em>git commit 的&rdquo;-m&quot;后面，是本次提交的说明，commont</em></li>
<li><em>git commit命令执行成功后会告诉你</em>
<ul>
<li><em>1 file changed：1个文件被改动（我们新添加的学习笔记）</em></li>
<li><em>108 insertions：插入了108行内容（该学习笔记当时108行）</em><!-- raw HTML omitted --></li>
</ul>
</li>
<li><em><!-- raw HTML omitted -->关于目录，Git是不进行目录管理的，而是只管理仓库内的文件</em></li>
<li><em>git add 可以操作目录（没毛用），git commit 操作目录会提示&quot;nothing to commit&quot;，如下<!-- raw HTML omitted --></em></li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git commit -m <span style="color:#e6db74">&#34;First Git Learn, it&#39;s learning notes directory.&#34;</span>
On branch master

Initial commit

nothing to commit
</code></pre></div><h4 id="322-git-status--git-diff">3.2.2 git status &amp; git diff</h4>
<p>可以用来查看接受Git管理的文件的修改状态，以及比较修改内容</p>
<ul>
<li><em><strong>git status</strong></em>
用于查看文件修改的状态，当前Git_Learn_Note.md已经被修改过，我们通过 <em><strong><code>git status</code></strong></em> 看看会告诉我们什么？</li>
</ul>
<p><img src="https://gitee.com/liujixia0410/picbed/raw/master/gitlearn/git_status_01.png" alt="git_status_01"></p>
<p>***<code>git status</code>***命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，Git_Learn_Note.md被修改过了(modified:   Git_Learn_Note.md)，但还没有准备提交的修改(no changes added to commit)。</p>
<ul>
<li><em><strong>git diff</strong></em>
虽然Git告诉我们Git_Learn_Note.md被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的Git_Learn_Note.md，所以，需要用 <em><strong><code>git diff</code></strong></em> 这个命令看看：</li>
</ul>
<p><img src="https://gitee.com/liujixia0410/picbed/raw/master/gitlearn/git_diff_01.png" alt="git_diff_01"></p>
<p><em><strong><code>git diff</code></strong></em> 顾名思义就是查看difference，显示的格式是Unix通用的diff格式，可以从上面的命令输出看到，我们在第186行删除了“疑难解答”四个字。</p>
<ul>
<li><em><strong>对于修改的提交</strong></em>
<ul>
<li>参考 &ldquo;3.2.1 add &amp; commit&rdquo; 章节</li>
<li>1、<em><strong><code>git add</code></strong></em></li>
<li>2、<em><strong><code>git commit</code></strong></em></li>
</ul>
</li>
</ul>
<h4 id="323-git-log--git-reset--git-reflog版本回退">3.2.3 git log &amp; git reset &amp; git reflog（版本回退）</h4>
<p>版本回退需要根据提交本版的日志情况，确定回退到以前的某个版本。</p>
<ul>
<li><em><strong>git log</strong></em>
在实际工作中，我们肯定记不住每次都改了什么内容，所以我们用***<code>git log</code>***命令查看：</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git log
commit 0471539bc0556b48a3371101fd98c17aabb0480e <span style="color:#f92672">(</span>HEAD -&gt; master<span style="color:#f92672">)</span>
Author: Liujx &lt;liujx@dce.com.cn&gt;
Date:   Wed Jan <span style="color:#ae81ff">13</span> 10:36:10 <span style="color:#ae81ff">2021</span> +0800

    Git Learning note: modified Git_learn_note.md

commit 47fb0e319187d32e1b2796080911f44e6d41a91c
Author: Liujx &lt;liujx@dce.com.cn&gt;
Date:   Wed Jan <span style="color:#ae81ff">13</span> 10:35:19 <span style="color:#ae81ff">2021</span> +0800

    Git Learning note: add images &amp; modified Git_learn_note.md

commit bbd52530c96650b49f27a14b6a09457bb8c528e1
Author: Liujx &lt;liujx@dce.com.cn&gt;
Date:   Wed Jan <span style="color:#ae81ff">13</span> 10:11:10 <span style="color:#ae81ff">2021</span> +0800

    My git learning note, git diff

commit 5284557de44e9f0efc6a932a3a1b81de55dd7bd6
Author: Liujx &lt;liujx@dce.com.cn&gt;
Date:   Mon Jan <span style="color:#ae81ff">11</span> 21:36:09 <span style="color:#ae81ff">2021</span> +0800

    Git learn: add commit status diff

commit d8ca75e78a1c7b06fcadd2bcc4fefdd7a9856c03
Author: Liujx &lt;liujx@dce.com.cn&gt;
Date:   Mon Jan <span style="color:#ae81ff">11</span> 20:38:41 <span style="color:#ae81ff">2021</span> +0800

    First Git Learn, it<span style="color:#960050;background-color:#1e0010">&#39;</span>s my git learning note.
</code></pre></div><p>***<code>git log</code>***命令显示从最近到最远的提交日志，我们可以看到5次提交，最近的一次是 <em><strong>Git Learning note: modified Git_learn_note.md</strong></em>，上一次是 <em><strong>Git Learning note: add images &amp; modified Git_learn_note.md</strong></em>，最早的一次是 <em><strong>First Git Learn, it&rsquo;s my git learning note.</strong></em> 。</p>
<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上 <em><strong><code>--pretty=oneline</code></strong></em> 参数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git log --pretty<span style="color:#f92672">=</span>oneline
0471539bc0556b48a3371101fd98c17aabb0480e <span style="color:#f92672">(</span>HEAD -&gt; master<span style="color:#f92672">)</span> Git Learning note: modified Git_learn_note.md
47fb0e319187d32e1b2796080911f44e6d41a91c Git Learning note: add images &amp; modified Git_learn_note.md
bbd52530c96650b49f27a14b6a09457bb8c528e1 My git learning note, git diff
5284557de44e9f0efc6a932a3a1b81de55dd7bd6 Git learn: add commit status diff
d8ca75e78a1c7b06fcadd2bcc4fefdd7a9856c03 First Git Learn, it<span style="color:#960050;background-color:#1e0010">&#39;</span>s my git learning note.
</code></pre></div><p><!-- raw HTML omitted -->友情提示:
你看到的一大串类似0471539bc&hellip;的是commit_id（版本号），和SVN不一样，Git的commit_id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit_id和我的肯定不一样，以你自己的为准。
为什么commit_id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。<!-- raw HTML omitted --></p>
<ul>
<li><em><strong>git reset</strong></em>
版本回退时，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交0471539bc&hellip;（注意我的提交ID和你的肯定不一样），上一个版本就是<!-- raw HTML omitted -->HEAD^<!-- raw HTML omitted -->，上上一个版本就是<!-- raw HTML omitted -->HEAD^^<!-- raw HTML omitted -->，当然往上100个版本写100个^是数不过来的，所以写成<!-- raw HTML omitted -->HEAD~100<!-- raw HTML omitted -->。</li>
</ul>
<p><em><strong>回退上一版本</strong></em>
为了演示更加清晰，新建一个文件gitversion.txt，然后进行两次修改提交，总共三个版本，内容分别如下（参考git log模式，时间从后往前排列）：
版本3：1st version. 2nd version. 3th version.
版本2：1st version. 2nd version.
版本1：1st version.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git log --pretty<span style="color:#f92672">=</span>oneline
a766f4ae555cd9a4a8b9e141da582f1a27ef9ab7 <span style="color:#f92672">(</span>HEAD -&gt; master<span style="color:#f92672">)</span> modify gitversion.txt 3th
92a45b1e176eaf979f95935a8c657215e367a787 modify gitversion.txt 2nd
8b59c8d2deb541ee00baae115c512ac27c44bef7 add gitversion.txt
</code></pre></div><p>从上述log内容看，新建了一个文件，并且修改了两次，当前最新版本是a766f4a&hellip;，我们要回退到上一版本92a45b1&hellip;，可以通过如下操作执行：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git reset --hard HEAD^
HEAD is now at 92a45b1 modify gitversion.txt 2nd

$ cat gitversion.txt
1st version. 2nd version.

$ git log --pretty<span style="color:#f92672">=</span>oneline
92a45b1e176eaf979f95935a8c657215e367a787 <span style="color:#f92672">(</span>HEAD -&gt; master<span style="color:#f92672">)</span> modify gitversion.txt 2nd
8b59c8d2deb541ee00baae115c512ac27c44bef7 add gitversion.txt
</code></pre></div><p>通过上述操作看到，果然回退到上一个版本了，并且通过 <em><strong><code>git log</code></strong></em> 看到当前最新版本的commit_id已经是92a45b1&hellip;了。</p>
<p><em><strong>回退任意版本</strong></em></p>
<p>但是，又想回到之前的最后一个版本a766f4a&hellip;怎么办？
只要窗口没关掉，或者你能通过任何方法找到版本的commit_id，就可以通过下面的方式，回到某个具体版本。
<em><!-- raw HTML omitted -->版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。<!-- raw HTML omitted --></em></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git reset --hard a766f4a
HEAD is now at a766f4a modify gitversion.txt 3th

$ cat gitversion.txt
1st version. 2nd version. 3th version.

$ git log --pretty<span style="color:#f92672">=</span>oneline
a766f4ae555cd9a4a8b9e141da582f1a27ef9ab7 <span style="color:#f92672">(</span>HEAD -&gt; master<span style="color:#f92672">)</span> modify gitversion.txt 3th
92a45b1e176eaf979f95935a8c657215e367a787 modify gitversion.txt 2nd
8b59c8d2deb541ee00baae115c512ac27c44bef7 add gitversion.txt
</code></pre></div><ul>
<li><em><strong>git reflog</strong></em></li>
</ul>
<p>上述提到的“只要窗口没关掉”，目的是为了找到某个版本的commit_id，只要能找到这个commit_id，窗口关掉几次都没关系，一样可以回退。但是窗口关掉之后，如何找到commit_id呢？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git reflog
a766f4a <span style="color:#f92672">(</span>HEAD -&gt; master<span style="color:#f92672">)</span> HEAD@<span style="color:#f92672">{</span>0<span style="color:#f92672">}</span>: reset: moving to a766f4a
92a45b1 HEAD@<span style="color:#f92672">{</span>1<span style="color:#f92672">}</span>: reset: moving to HEAD^
a766f4a <span style="color:#f92672">(</span>HEAD -&gt; master<span style="color:#f92672">)</span> HEAD@<span style="color:#f92672">{</span>2<span style="color:#f92672">}</span>: commit: modify gitversion.txt 3th
92a45b1 HEAD@<span style="color:#f92672">{</span>3<span style="color:#f92672">}</span>: commit: modify gitversion.txt 2nd
8b59c8d HEAD@<span style="color:#f92672">{</span>4<span style="color:#f92672">}</span>: commit: add gitversion.txt
</code></pre></div><p>Git提供了一个命令 <em><strong><code>git reflog</code></strong></em> 用来记录你每一次执行的命令，有了这个，放心回退吧。</p>
<ul>
<li><em><strong>git版本回退原理</strong></em></li>
</ul>
<p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向到某个版本：</p>
<p>┌────┐
│HEAD│
└────┘
└──&gt; ○ modify gitversion.txt 3th
　　　│
　　　○ modify gitversion.txt 2nd
　　　│
　　　○ add gitversion.txt</p>
<p>改为指向 modify gitversion.txt 2nd：</p>
<p>┌────┐
│HEAD│
└────┘
│　　○ append GPL
│　　│
└──&gt; ○ add distributed
　　　│
　　　○ wrote a readme file</p>
<p>然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。</p>
<h4 id="324-工作区--暂存区">3.2.4 工作区 &amp; 暂存区</h4>
<ul>
<li><strong>工作区（Working Directory）</strong>
就是在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cd /z/Git/learngit
$ ll
total <span style="color:#ae81ff">0</span>
drwxr-xr-x <span style="color:#ae81ff">1</span> lenovo <span style="color:#ae81ff">197121</span> <span style="color:#ae81ff">0</span>  1月 <span style="color:#ae81ff">13</span> 14:59 git_learn_notes/

$ cd git_learn_notes
$ ll
total <span style="color:#ae81ff">17</span>
-rw-r--r-- <span style="color:#ae81ff">1</span> lenovo <span style="color:#ae81ff">197121</span> <span style="color:#ae81ff">14170</span>  1月 <span style="color:#ae81ff">13</span> 16:18 Git_Learn_Note.md
-rw-r--r-- <span style="color:#ae81ff">1</span> lenovo <span style="color:#ae81ff">197121</span>    <span style="color:#ae81ff">40</span>  1月 <span style="color:#ae81ff">13</span> 14:59 gitversion.txt
drwxr-xr-x <span style="color:#ae81ff">1</span> lenovo <span style="color:#ae81ff">197121</span>     <span style="color:#ae81ff">0</span>  1月 <span style="color:#ae81ff">13</span> 10:42 image/
</code></pre></div><ul>
<li><strong>版本库（Repository）&amp; 暂存区（stage）</strong></li>
</ul>
<p>工作区有一个隐藏目录 <em>.git</em>，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。
（分支和HEAD的概念后面再说）</p>
<p><img src="https://gitee.com/liujixia0410/picbed/raw/master/gitlearn/git_repository.png" alt="git_repository"></p>
<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：
第一步是用 <em><strong><code>git add</code></strong></em> 把文件添加进去，实际上就是把文件修改添加到暂存区；
第二步是用 <em><strong><code>git commit</code></strong></em> 提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，<em><strong><code>git commit</code></strong></em> 就是往master分支上提交更改。
你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<p>我们再练习一遍，先对gitversion.txt做个修改，比如加上一行内容：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">1st version. 2nd version. 3th version.
Git has a mutable index called stage.
</code></pre></div><p>然后，在工作区新增一个git_test.txt文本文件（内容随便写）。</p>
<p>先用git status查看一下状态：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git status
On branch master
Changes not staged <span style="color:#66d9ef">for</span> commit:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add &lt;file&gt;...&#34;</span> to update what will be committed<span style="color:#f92672">)</span>
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git restore &lt;file&gt;...&#34;</span> to discard changes in working directory<span style="color:#f92672">)</span>
        modified:   gitversion.txt

Untracked files:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add &lt;file&gt;...&#34;</span> to include in what will be committed<span style="color:#f92672">)</span>
        git_test.txt

no changes added to commit <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add&#34;</span> and/or <span style="color:#e6db74">&#34;git commit -a&#34;</span><span style="color:#f92672">)</span>
</code></pre></div><p>Git非常清楚地告诉我们，gitversion.txt被修改了，而git_test.txt还从来没有被添加过，所以它的状态是Untracked。</p>
<p>现在，使用两次命令 <em><strong><code>git add</code></strong></em>，把gitversion.txt和git_test.txt都添加后，用git status再查看一下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git status
On branch master
Changes to be committed:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git restore --staged &lt;file&gt;...&#34;</span> to unstage<span style="color:#f92672">)</span>
        new file:   git_test.txt
        modified:   gitversion.txt
</code></pre></div><p>现在，暂存区的状态就变成这样了：</p>
<p><img src="https://gitee.com/liujixia0410/picbed/raw/master/gitlearn/git_stage.png" alt="git_stage"></p>
<p>所以，<em><strong><code>git add</code></strong></em> 命令实际上就是把要提交的所有修改放到 <strong>暂存区（Stage）</strong>，然后，执行 <em><strong><code>git commit</code></strong></em> 就可以一次性把暂存区的所有修改提交到分支。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git commit -m <span style="color:#e6db74">&#34;Git learn: stage&#34;</span>
<span style="color:#f92672">[</span>master 4af1b44<span style="color:#f92672">]</span> Git learn: stage
 <span style="color:#ae81ff">2</span> files changed, <span style="color:#ae81ff">1</span> insertion<span style="color:#f92672">(</span>+<span style="color:#f92672">)</span>
 create mode <span style="color:#ae81ff">100644</span> git_learn_notes/git_test.txt
</code></pre></div><p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git status
On branch master
nothing to commit, working tree clean
</code></pre></div><p>现在版本库变成了这样，暂存区就没有任何内容了：</p>
<p><img src="https://gitee.com/liujixia0410/picbed/raw/master/gitlearn/git_stage_after_commit.png" alt="git_stage_after_commit"></p>
<h4 id="325-管理修改而非文件">3.2.5 管理修改而非文件</h4>
<p><strong>问：为什么Git比其他版本控制系统设计得优秀？</strong>
<strong>答：因为Git跟踪并管理的是<!-- raw HTML omitted -->修改<!-- raw HTML omitted -->，而非文件。任何增删改，都是修改</strong></p>
<p>我们做一个实验，看看Git是如何管理修改，而不是管理文件的。</p>
<p>第一步，对gitversion.txt添加一行(Git tracks changes.)：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">1st version. 2nd version. 3th version.
Git has a mutable index called stage.
Git tracks changes.
</code></pre></div><p>第二步，<em><strong><code>git add</code></strong></em> 将第一次修改放入暂存区</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git add gitversion.txt
$ git status
On branch master
Changes to be committed:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git restore --staged &lt;file&gt;...&#34;</span> to unstage<span style="color:#f92672">)</span>
        modified:   gitversion.txt
</code></pre></div><p>第三步，再次修改gitversion.txt，再添加一行(Git tracks changes of files 2nd.)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">1st version. 2nd version. 3th version.
Git has a mutable index called stage.
Git tracks changes.
Git tracks changes of files 2nd.
</code></pre></div><p>第四步，<em><strong><code>git commit</code></strong></em>，然后 <em><strong><code>git status</code></strong></em> 再看状态</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git commit -m <span style="color:#e6db74">&#34;Git test: git tracks changes&#34;</span>
<span style="color:#f92672">[</span>master 652163d<span style="color:#f92672">]</span> Git test: git tracks changes
 <span style="color:#ae81ff">1</span> file changed, <span style="color:#ae81ff">2</span> insertions<span style="color:#f92672">(</span>+<span style="color:#f92672">)</span>, <span style="color:#ae81ff">1</span> deletion<span style="color:#f92672">(</span>-<span style="color:#f92672">)</span>

$ git status
On branch master
Changes not staged <span style="color:#66d9ef">for</span> commit:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add &lt;file&gt;...&#34;</span> to update what will be committed<span style="color:#f92672">)</span>
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git restore &lt;file&gt;...&#34;</span> to discard changes in working directory<span style="color:#f92672">)</span>
        modified:   gitversion.txt

no changes added to commit <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add&#34;</span> and/or <span style="color:#e6db74">&#34;git commit -a&#34;</span><span style="color:#f92672">)</span>
</code></pre></div><p>至此，你会发现，<strong>第二次修改没有被提交！第二次修改没有被提交！第二次修改没有被提交！</strong></p>
<p>原因如下：
第一次修改 -&gt; <em><strong><code>git add</code></strong></em> -&gt; 第二次修改 -&gt; <em><strong><code>git commit</code></strong></em></p>
<p>你看，前面提到了Git管理的是修改，当使用 <em><strong><code>git add</code></strong></em> 命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<em><strong><code>git commit</code></strong></em> 只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>
<p>提交后，用 <em><strong><code>git diff</code></strong></em> 命令可以查看工作区和版本库里面最新版本的区别，可见，第二次修改确实没有被提交。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git diff
diff --git a/git_learn_notes/gitversion.txt b/git_learn_notes/gitversion.txt
index 42b2849..fd43f3f <span style="color:#ae81ff">100644</span>
--- a/git_learn_notes/gitversion.txt
+++ b/git_learn_notes/gitversion.txt
@@ -1,3 +1,4 @@
 1st version. 2nd version. 3th version.
 Git has a mutable index called stage.
-Git tracks changes.
<span style="color:#ae81ff">\ </span>No newline at end of file
+Git tracks changes.
+Git tracks changes of files 2nd.
<span style="color:#ae81ff">\ </span>No newline at end of file
</code></pre></div><h4 id="326-撤销修改-git-restore">3.2.6 撤销修改 git restore</h4>
<p>撤销修改分为两类</p>
<ol>
<li>撤销 <em><strong><code>git add</code></strong></em> 之前的修改内容</li>
<li>撤销 <em><strong><code>git add</code></strong></em> 之后，还未 <em><strong><code>git commit</code></strong></em> 的修改内容</li>
</ol>
<ul>
<li><strong>git add 之前 撤销</strong></li>
</ul>
<p>先对gitversion.txt进行修改，添加一行&quot;Git undo change before add.&quot;。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat gitversion.txt
1st version. 2nd version. 3th version.
Git has a mutable index called stage.
Git tracks changes.
Git tracks changes of files 2nd.
Git undo change before add.
</code></pre></div><p>通过 <em><strong><code>git status</code></strong></em> 查看当前状态</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git status
On branch master
Changes not staged <span style="color:#66d9ef">for</span> commit:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add &lt;file&gt;...&#34;</span> to update what will be committed<span style="color:#f92672">)</span>
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git restore &lt;file&gt;...&#34;</span> to discard changes in working directory<span style="color:#f92672">)</span>
        modified:   gitversion.txt

no changes added to commit <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add&#34;</span> and/or <span style="color:#e6db74">&#34;git commit -a&#34;</span><span style="color:#f92672">)</span>
</code></pre></div><p>我们会发现，Git告诉我们，<em><strong><code>git restore &lt;filename&gt;...</code></strong></em> 可以丢弃工作区的修改，尝试一下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git restore gitversion.txt

$ git status
On branch master
nothing to commit, working tree clean

$ cat gitversion.txt
1st version. 2nd version. 3th version.
Git has a mutable index called stage.
Git tracks changes.
Git tracks changes of files 2nd.
</code></pre></div><p>命令 <em><strong><code>git restore gitversion.txt</code></strong></em> 意思就是，把gitversion.txt文件在工作区的修改全部撤销，这里有两种情况：
一种是gitversion.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；
一种是gitversion.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次 <em><strong><code>git commit</code></strong></em> 或 <em><strong><code>git add</code></strong></em> 时的状态。
从上述输出看，文件内容果然复原了。</p>
<ul>
<li><strong>git add 之后 撤销</strong></li>
</ul>
<p>如果修改后执行了 <em><strong><code>git add</code></strong></em> 怎么办？我们再来操作一下。
先添加一句话&quot;Git undo change after add.&quot;，再执行 <em><strong><code>git add</code></strong></em>；
执行 <em><strong><code>git commit</code></strong></em> 之前，我们发现这句话错了，***<code>git status</code>***看一下，发现修改只是添加到暂存区，还未提交。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat gitversion.txt
1st version. 2nd version. 3th version.
Git has a mutable index called stage.
Git tracks changes.
Git tracks changes of files 2nd.
Git undo change after add.

$ git add gitversion.txt

$ git status
On branch master
Changes to be committed:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git restore --staged &lt;file&gt;...&#34;</span> to unstage<span style="color:#f92672">)</span>
        modified:   gitversion.txt
</code></pre></div><p>我们发现，Git同样告诉我们，用命令 <em><strong><code>git restore --staged &lt;file&gt;...</code></strong></em> 可以把暂存区的修改撤销掉（unstage），重新放回工作区，我们尝试一下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git restore --staged gitversion.txt

$ git status
On branch master
Changes not staged <span style="color:#66d9ef">for</span> commit:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add &lt;file&gt;...&#34;</span> to update what will be committed<span style="color:#f92672">)</span>
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git restore &lt;file&gt;...&#34;</span> to discard changes in working directory<span style="color:#f92672">)</span>
        modified:   gitversion.txt

no changes added to commit <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add&#34;</span> and/or <span style="color:#e6db74">&#34;git commit -a&#34;</span><span style="color:#f92672">)</span>

$ cat gitversion.txt
1st version. 2nd version. 3th version.
Git has a mutable index called stage.
Git tracks changes.
Git tracks changes of files 2nd.
Git undo change after add.
</code></pre></div><p>我们可以看到，暂存区干净了，工作区还存在文件修改，查看一下文件内容，&ldquo;Git undo change after add.&ldquo;这句不该存在的内容确实还在。</p>
<p>接下来呢，按照“撤销 <em><strong><code>git add</code></strong></em> 之前的修改”在操作一次就行了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git restore gitversion.txt

$ git status
On branch master
nothing to commit, working tree clean

$ cat gitversion.txt
1st version. 2nd version. 3th version.
Git has a mutable index called stage.
Git tracks changes.
Git tracks changes of files 2nd.
</code></pre></div><p>到这里，全干净了，***<code>git status</code>***什么也没有了，查看文件内容，&ldquo;Git undo change after add.&ldquo;这句确实不存在了，一切都回到了原点。</p>
<p>撤销修改，除了使用 <em><strong><code>git restore</code></strong></em> 之外，还可以使用 <em><strong><code>git checkout -- &lt;filename&gt;</code></strong></em> 命令，该命令此处不做详细介绍。</p>
<h4 id="327-删除文件-git-rm">3.2.7 删除文件 git rm</h4>
<p>Git中，删除也被当做一种修改操作来管理。我们试着删除之前曾经提交过的&quot;git_test.txt&quot;文件。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ll
total <span style="color:#ae81ff">29</span>
-rw-r--r-- <span style="color:#ae81ff">1</span> lenovo <span style="color:#ae81ff">197121</span> <span style="color:#ae81ff">24390</span>  1月 <span style="color:#ae81ff">19</span> 19:36 Git_Learn_Note.md
-rw-r--r-- <span style="color:#ae81ff">1</span> lenovo <span style="color:#ae81ff">197121</span>     <span style="color:#ae81ff">0</span>  1月 <span style="color:#ae81ff">13</span> 16:40 git_test.txt
-rw-r--r-- <span style="color:#ae81ff">1</span> lenovo <span style="color:#ae81ff">197121</span>   <span style="color:#ae81ff">132</span>  1月 <span style="color:#ae81ff">19</span> 19:32 gitversion.txt

$ rm git_test.txt

$ ll
total <span style="color:#ae81ff">29</span>
-rw-r--r-- <span style="color:#ae81ff">1</span> lenovo <span style="color:#ae81ff">197121</span> <span style="color:#ae81ff">24390</span>  1月 <span style="color:#ae81ff">19</span> 19:36 Git_Learn_Note.md
-rw-r--r-- <span style="color:#ae81ff">1</span> lenovo <span style="color:#ae81ff">197121</span>   <span style="color:#ae81ff">132</span>  1月 <span style="color:#ae81ff">19</span> 19:32 gitversion.txt
</code></pre></div><p>此时，Git知道有文件被删除了，工作区和版本库不一致了，***<code>git status</code>***命令会告诉哪些文件被删除了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git status
On branch master
Changes not staged <span style="color:#66d9ef">for</span> commit:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add/rm &lt;file&gt;...&#34;</span> to update what will be committed<span style="color:#f92672">)</span>
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git restore &lt;file&gt;...&#34;</span> to discard changes in working directory<span style="color:#f92672">)</span>
        deleted:    git_test.txt

no changes added to commit <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add&#34;</span> and/or <span style="color:#e6db74">&#34;git commit -a&#34;</span><span style="color:#f92672">)</span>
</code></pre></div><p>此时可以有两个选择</p>
<ol>
<li>一是删除错了，要从版本库恢复回来，使用命令 <em><strong><code>git restore</code></strong></em>
通过以下执行，可以看到，&ldquo;git_test.txt&quot;被恢复回来了，<em><strong><code>git status</code></strong></em> 也是干净的。</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git restore git_test.txt

$ ll
total <span style="color:#ae81ff">29</span>
-rw-r--r-- <span style="color:#ae81ff">1</span> lenovo <span style="color:#ae81ff">197121</span> <span style="color:#ae81ff">24390</span>  1月 <span style="color:#ae81ff">19</span> 19:36 Git_Learn_Note.md
-rw-r--r-- <span style="color:#ae81ff">1</span> lenovo <span style="color:#ae81ff">197121</span>     <span style="color:#ae81ff">0</span>  1月 <span style="color:#ae81ff">22</span> 14:00 git_test.txt
-rw-r--r-- <span style="color:#ae81ff">1</span> lenovo <span style="color:#ae81ff">197121</span>   <span style="color:#ae81ff">132</span>  1月 <span style="color:#ae81ff">19</span> 19:32 gitversion.txt

$ git status
On branch master
nothing to commit, working tree clean
</code></pre></div><ol start="2">
<li>二是确实要从版本库中删除该文件，使用命令 <em><strong><code>git rm</code></strong></em> 删掉，并且 <em><strong><code>git commit</code></strong></em>
通过以下执行，可以看到，&ldquo;git_test.txt&quot;已经不存在了，并且 <em><strong><code>git status</code></strong></em> 也是干净的。</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git rm git_test.txt
rm <span style="color:#e6db74">&#39;git_learn_notes/git_test.txt&#39;</span>

$ git commit -m <span style="color:#e6db74">&#34;Git learn: git rm&#34;</span>
<span style="color:#f92672">[</span>master 7398e9d<span style="color:#f92672">]</span> Git learn: git rm
 <span style="color:#ae81ff">1</span> file changed, <span style="color:#ae81ff">0</span> insertions<span style="color:#f92672">(</span>+<span style="color:#f92672">)</span>, <span style="color:#ae81ff">0</span> deletions<span style="color:#f92672">(</span>-<span style="color:#f92672">)</span>
 delete mode <span style="color:#ae81ff">100644</span> git_learn_notes/git_test.txt

$ git status
On branch master
nothing to commit, working tree clean

$ ll
total <span style="color:#ae81ff">29</span>
-rw-r--r-- <span style="color:#ae81ff">1</span> lenovo <span style="color:#ae81ff">197121</span> <span style="color:#ae81ff">24390</span>  1月 <span style="color:#ae81ff">19</span> 19:36 Git_Learn_Note.md
-rw-r--r-- <span style="color:#ae81ff">1</span> lenovo <span style="color:#ae81ff">197121</span>   <span style="color:#ae81ff">132</span>  1月 <span style="color:#ae81ff">19</span> 19:32 gitversion.txt
</code></pre></div><h2 id="四远程版本库">四、远程版本库</h2>
<p>GitHub也可以创建Git仓库，并且让GitHub与本地仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。</p>
<h3 id="41-添加到远程仓库-git-remote--git-push">4.1 添加到远程仓库 git remote &amp; git push</h3>
<p>首先，注册并登录GitHub，创建一个仓库。我针对Git学习，创建一个叫做learngit的仓库。创建后，仓库是空的。</p>
<p>GitHub给出了很明确的提示，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>
<p>GitHub提示信息如下：</p>
<p><img src="https://gitee.com/liujixia0410/picbed/raw/master/gitlearn/GitHub_new_repo.png" alt="GitHub_new_repo"></p>
<p>现在，根据GitHub的提示，在本地的learngit仓库下运行命令：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git remote add origin http://github.com/liujixia0410/learngit.git
</code></pre></div><p>上面的liujixia0410需要替换成自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p>
<p>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</p>
<p>下一步，就可以把本地库的所有内容推送到远程库上：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git push -u origin master
warning: redirecting to https://github.com/liujixia0410/learngit.git/
Enumerating objects: 79, <span style="color:#66d9ef">done</span>.
Counting objects: 100% <span style="color:#f92672">(</span>79/79<span style="color:#f92672">)</span>, <span style="color:#66d9ef">done</span>.
Delta compression using up to <span style="color:#ae81ff">8</span> threads
Compressing objects: 100% <span style="color:#f92672">(</span>55/55<span style="color:#f92672">)</span>, <span style="color:#66d9ef">done</span>.
Writing objects: 100% <span style="color:#f92672">(</span>79/79<span style="color:#f92672">)</span>, 193.28 KiB | 7.73 MiB/s, <span style="color:#66d9ef">done</span>.
Total <span style="color:#ae81ff">79</span> <span style="color:#f92672">(</span>delta 16<span style="color:#f92672">)</span>, reused <span style="color:#ae81ff">0</span> <span style="color:#f92672">(</span>delta 0<span style="color:#f92672">)</span>
remote: Resolving deltas: 100% <span style="color:#f92672">(</span>16/16<span style="color:#f92672">)</span>, <span style="color:#66d9ef">done</span>.
To http://github.com/liujixia0410/learngit.git
 * <span style="color:#f92672">[</span>new branch<span style="color:#f92672">]</span>      master -&gt; master
Branch <span style="color:#e6db74">&#39;master&#39;</span> set up to track remote branch <span style="color:#e6db74">&#39;master&#39;</span> from <span style="color:#e6db74">&#39;origin&#39;</span>.
</code></pre></div><p>把本地库的内容推送到远程，用 <em><strong><code>git push</code></strong></em> 命令，实际上是把当前分支master推送到远程。</p>
<p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>推送成功后的Git页面，与本地一样了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ll
total <span style="color:#ae81ff">33</span>
-rw-r--r-- <span style="color:#ae81ff">1</span> lenovo <span style="color:#ae81ff">197121</span> <span style="color:#ae81ff">26672</span>  1月 <span style="color:#ae81ff">22</span> 15:07 Git_Learn_Note.md
-rw-r--r-- <span style="color:#ae81ff">1</span> lenovo <span style="color:#ae81ff">197121</span>   <span style="color:#ae81ff">132</span>  1月 <span style="color:#ae81ff">19</span> 19:32 gitversion.txt
drwxr-xr-x <span style="color:#ae81ff">1</span> lenovo <span style="color:#ae81ff">197121</span>     <span style="color:#ae81ff">0</span>  1月 <span style="color:#ae81ff">13</span> 16:50 image/
</code></pre></div><p><img src="https://gitee.com/liujixia0410/picbed/raw/master/gitlearn/GitHub_push_01.png" alt="GitHub_push_01"></p>
<p>从现在起，只要本地作了提交，就可以通过命令 <em><strong><code>git push</code></strong></em> 推送到GitHub上，现在就是真正的分布式版本库了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git status
On branch master
Your branch is up to date with <span style="color:#e6db74">&#39;origin/master&#39;</span>.

Changes not staged <span style="color:#66d9ef">for</span> commit:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add &lt;file&gt;...&#34;</span> to update what will be committed<span style="color:#f92672">)</span>
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git restore &lt;file&gt;...&#34;</span> to discard changes in working directory<span style="color:#f92672">)</span>
        modified:   Git_Learn_Note.md

no changes added to commit <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add&#34;</span> and/or <span style="color:#e6db74">&#34;git commit -a&#34;</span><span style="color:#f92672">)</span>

$ git add Git_Learn_Note.md

$ git commit -m <span style="color:#e6db74">&#34;Git learn: git push&#34;</span>
<span style="color:#f92672">[</span>master 8f497b1<span style="color:#f92672">]</span> Git learn: git push
 <span style="color:#ae81ff">1</span> file changed, <span style="color:#ae81ff">82</span> insertions<span style="color:#f92672">(</span>+<span style="color:#f92672">)</span>

$ git push origin master
warning: redirecting to https://github.com/liujixia0410/learngit.git/
Enumerating objects: 7, <span style="color:#66d9ef">done</span>.
Counting objects: 100% <span style="color:#f92672">(</span>7/7<span style="color:#f92672">)</span>, <span style="color:#66d9ef">done</span>.
Delta compression using up to <span style="color:#ae81ff">8</span> threads
Compressing objects: 100% <span style="color:#f92672">(</span>3/3<span style="color:#f92672">)</span>, <span style="color:#66d9ef">done</span>.
Writing objects: 100% <span style="color:#f92672">(</span>4/4<span style="color:#f92672">)</span>, 2.30 KiB | 336.00 KiB/s, <span style="color:#66d9ef">done</span>.
Total <span style="color:#ae81ff">4</span> <span style="color:#f92672">(</span>delta 1<span style="color:#f92672">)</span>, reused <span style="color:#ae81ff">0</span> <span style="color:#f92672">(</span>delta 0<span style="color:#f92672">)</span>
remote: Resolving deltas: 100% <span style="color:#f92672">(</span>1/1<span style="color:#f92672">)</span>, completed with <span style="color:#ae81ff">1</span> local object.
To http://github.com/liujixia0410/learngit.git
   3fb1270..8f497b1  master -&gt; master

$ git status
On branch master
Your branch is up to date with <span style="color:#e6db74">&#39;origin/master&#39;</span>.

nothing to commit, working tree clean
</code></pre></div><h3 id="42-从远程仓库克隆-git-clone">4.2 从远程仓库克隆 git clone</h3>
<p>现在，假设我们先有一个远程库，然后，从远程库克隆。</p>
<p>首先，登陆GitHub，创建一个新的仓库，名字叫gitremotetest，勾选</p>
<pre><code>Initialize this repository with a README
</code></pre><p>这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件。</p>
<p>现在，远程库已经准备好了，使用命令 <em><strong><code>git clone</code></strong></em> 克隆一个本地库。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ll
total <span style="color:#ae81ff">57</span>
-rwxr-xr-x <span style="color:#ae81ff">1</span> lenovo <span style="color:#ae81ff">197121</span>  <span style="color:#ae81ff">5114</span> 12月 <span style="color:#ae81ff">14</span> 19:57 github.sh*
drwxr-xr-x <span style="color:#ae81ff">1</span> lenovo <span style="color:#ae81ff">197121</span>     <span style="color:#ae81ff">0</span>  1月 <span style="color:#ae81ff">11</span> 20:32 learngit/

$ git clone git@github.com:liujixia0410/gitremotetest.git
Cloning into <span style="color:#e6db74">&#39;gitremotetest&#39;</span>...
remote: Enumerating objects: 3, <span style="color:#66d9ef">done</span>.
remote: Counting objects: 100% <span style="color:#f92672">(</span>3/3<span style="color:#f92672">)</span>, <span style="color:#66d9ef">done</span>.
remote: Total <span style="color:#ae81ff">3</span> <span style="color:#f92672">(</span>delta 0<span style="color:#f92672">)</span>, reused <span style="color:#ae81ff">0</span> <span style="color:#f92672">(</span>delta 0<span style="color:#f92672">)</span>, pack-reused <span style="color:#ae81ff">0</span>
Receiving objects: 100% <span style="color:#f92672">(</span>3/3<span style="color:#f92672">)</span>, <span style="color:#66d9ef">done</span>.

$ ll
total <span style="color:#ae81ff">57</span>
-rwxr-xr-x <span style="color:#ae81ff">1</span> lenovo <span style="color:#ae81ff">197121</span>  <span style="color:#ae81ff">5114</span> 12月 <span style="color:#ae81ff">14</span> 19:57 github.sh*
drwxr-xr-x <span style="color:#ae81ff">1</span> lenovo <span style="color:#ae81ff">197121</span>     <span style="color:#ae81ff">0</span>  1月 <span style="color:#ae81ff">23</span> 22:27 gitremotetest/
drwxr-xr-x <span style="color:#ae81ff">1</span> lenovo <span style="color:#ae81ff">197121</span>     <span style="color:#ae81ff">0</span>  1月 <span style="color:#ae81ff">11</span> 20:32 learngit/
</code></pre></div><p>GitHub给出的地址不止一个，还可以用 <a href="https://github.com/liujixia0410/gitremotetest.git">https://github.com/liujixia0410/gitremotetest.git</a> 这样的地址。实际上，Git支持多种协议，默认的 git:// 使用ssh，但也可以使用https等其他协议。</p>
<p>使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</p>
<h2 id="五分支管理">五、分支管理</h2>
<p>分支概念在这里就不介绍了，学习Git的前提，应该是已经使用过其他的版本管理工具，比如SVN，对分支已经有一些了解。</p>
<p>本章节，仅介绍Git与其他版本管理工具在分支管理方面的区别，看看Git为什么更好。</p>
<h3 id="51-创建与合并分支">5.1 创建与合并分支</h3>
<p>在版本回退里，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。</p>
<p>截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p>
<p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点，比如下图：</p>
<p><img src="https://gitee.com/liujixia0410/picbed/raw/master/gitlearn/git_branch_init.png" alt="git_branch_init"></p>
<p>每次提交，master分支都会向前移动一步，这样，随着不断提交，master分支的线也越来越长。</p>
<p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上。</p>
<p><img src="https://gitee.com/liujixia0410/picbed/raw/master/gitlearn/git_branch_create.png" alt="git_branch_create"></p>
<p>Git创建一个分支很快的原因就在这，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化。</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变。</p>
<p><img src="https://gitee.com/liujixia0410/picbed/raw/master/gitlearn/git_branch_brlearn.png" alt="git_branch_brlearn"></p>
<p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并。</p>
<p><img src="https://gitee.com/liujixia0410/picbed/raw/master/gitlearn/git_branch_merge.png" alt="git_branch_merge"></p>
<p>所以Git合并分支也很快，就改改指针，工作区内容也不变。</p>
<p>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支。</p>
<p><img src="https://gitee.com/liujixia0410/picbed/raw/master/gitlearn/git_branch_rm.png" alt="git_branch_rm"></p>
<p>到这，通过分支dev的一系列操作和提交，都全部合并到master了，但是我们都看不出来曾经有过一个dev分支。。。。。。</p>
<p>下面，具体操作一次。</p>
<h4 id="511-创建和切换分支-git-branch--git-checkout">5.1.1 创建和切换分支 git branch &amp; git checkout</h4>
<p>我们先创建并且换到一个新的分支上，分支命名&quot;brlearn&rdquo;（对应上文描述原理中的dev）。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git checkout -b brlearn
Switched to a new branch <span style="color:#e6db74">&#39;brlearn&#39;</span>

$ git branch
* brlearn
  master
</code></pre></div><p><em><strong><code>git checkout</code></strong></em> 命令加上 <em><strong><code>-b</code></strong></em> 参数表示创建并切换，相当于以下两条命令。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git branch brlearn
$ git checkout brlearn
Switched to a new branch <span style="color:#e6db74">&#39;brlearn&#39;</span>

$ git branch
* brlearn
  master
</code></pre></div><p><em><strong><code>git branch</code></strong></em> 命令会列出所有分支，当前分支前面标注*号。</p>
<p>现在已经在 <em>brlearn</em> 分支上了，我们在&quot;gitversion.txt&quot;里增加一行&quot;Git branch brlearn add 1st.&quot;。然后提交，看看 <em>brlearn</em> 分支与 <em>master</em> 的区别。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git branch
* brlearn
  master

$ cat gitversion.txt
1st version. 2nd version. 3th version.
Git has a mutable index called stage.
Git tracks changes.
Git tracks changes of files 2nd.
Git branch brlearn add 1st.

$ git status
On branch brlearn
Changes not staged <span style="color:#66d9ef">for</span> commit:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add &lt;file&gt;...&#34;</span> to update what will be committed<span style="color:#f92672">)</span>
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git restore &lt;file&gt;...&#34;</span> to discard changes in working directory<span style="color:#f92672">)</span>
        modified:   gitversion.txt

no changes added to commit <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add&#34;</span> and/or <span style="color:#e6db74">&#34;git commit -a&#34;</span><span style="color:#f92672">)</span>

$ git add gitversion.txt

$ git commit -m <span style="color:#e6db74">&#34;Git learn: git branch brlearn&#34;</span>
<span style="color:#f92672">[</span>brlearn cf09a3c<span style="color:#f92672">]</span> Git learn: git branch brlearn
 <span style="color:#ae81ff">1</span> file changed, <span style="color:#ae81ff">2</span> insertions<span style="color:#f92672">(</span>+<span style="color:#f92672">)</span>, <span style="color:#ae81ff">1</span> deletion<span style="color:#f92672">(</span>-<span style="color:#f92672">)</span>

$ git checkout master
Switched to branch <span style="color:#e6db74">&#39;master&#39;</span>
Your branch is up to date with <span style="color:#e6db74">&#39;origin/master&#39;</span>.

$ git branch
  brlearn
* master

$ cat gitversion.txt
1st version. 2nd version. 3th version.
Git has a mutable index called stage.
Git tracks changes.
Git tracks changes of files 2nd.
</code></pre></div><p>切换回 <em>master</em> 分支后，发现&quot;gitversion.txt&quot;刚才添加的内容不见了！因为那个提交是在 <em>brlearn</em> 分支上，而 <em>master</em> 分支此刻的提交点并没有变。</p>
<p><img src="https://gitee.com/liujixia0410/picbed/raw/master/gitlearn/git_branch_on_master.png" alt="git_branch_on_master"></p>
<h4 id="512-合并-git-merge">5.1.2 合并 git merge</h4>
<p>现在我们把 <em>brlearn</em> 分支合并回 <em>master</em> ，使用 <em><strong><code>git merge</code></strong></em> 命令。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git branch
  brlearn
* master

$ git merge brlearn
Updating 946c07b..cf09a3c
Fast-forward
 git_learn_notes/gitversion.txt | <span style="color:#ae81ff">3</span> ++-
 <span style="color:#ae81ff">1</span> file changed, <span style="color:#ae81ff">2</span> insertions<span style="color:#f92672">(</span>+<span style="color:#f92672">)</span>, <span style="color:#ae81ff">1</span> deletion<span style="color:#f92672">(</span>-<span style="color:#f92672">)</span>

$ cat gitversion.txt
1st version. 2nd version. 3th version.
Git has a mutable index called stage.
Git tracks changes.
Git tracks changes of files 2nd.
Git branch brlearn add 1st.
</code></pre></div><p><em><strong><code>git merge</code></strong></em> 命令用于合并指定分支到当前分支。合并后，再查看<code>gitversion.txt</code>的内容，就可以看到，和*<code>brlearn</code>* 分支是一样的了。</p>
<p>另外，我们注意上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把 <em><code>master</code></em> 指向 <em><code>brlearn</code></em> 的当前提交，所以合并速度非常快。</p>
<p>当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。</p>
<p>合并完成后，就可以放心地删除 <em><code>brlearn</code></em> 分支了，删除后，查看 <em><code>branch</code></em>，就只剩下 <em><code>master</code></em> 分支了。如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git branch -d brlearn
Deleted branch brlearn <span style="color:#f92672">(</span>was cf09a3c<span style="color:#f92672">)</span>.

$ git branch
* master
</code></pre></div><p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在 <em><code>master</code></em> 分支上工作效果是一样的，但过程更安全。</p>
<h4 id="513-切换分支-git-switch">5.1.3 切换分支 git switch</h4>
<p>我们注意到切换分支使用 <em><strong><code>git checkout &lt;branch&gt;</code></strong></em>，而前面讲过，撤销修改也可以使用 <em><strong><code>git checkout -- &lt;file&gt;</code></strong></em>，同一个命令，有两种作用，确实很容易搞混。</p>
<p>实际上，切换分支这个动作，用<code>switch</code>更科学。因此，最新版本的Git提供了新的 <em><strong><code>git switch</code></strong></em> 命令来切换分支。（<em><strong><code>git switch</code></strong></em> 确实比 <em><strong><code>git checkout</code></strong></em> 更容易理解）</p>
<p>创建并切换到新的 <em><code>brlearn</code></em> 分支：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git switch -c brlearn
Switched to a new branch <span style="color:#e6db74">&#39;brlearn&#39;</span>

$ git branch
* brlearn
  master
</code></pre></div><p>直接切换到已有的<code>master</code>分支：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git switch master
Switched to branch <span style="color:#e6db74">&#39;master&#39;</span>
Your branch is ahead of <span style="color:#e6db74">&#39;origin/master&#39;</span> by <span style="color:#ae81ff">1</span> commit.
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git push&#34;</span> to publish your local commits<span style="color:#f92672">)</span>

$ git branch
  brlearn
* master
</code></pre></div><h3 id="52-解决冲突人工合并">5.2 解决冲突（人工合并）</h3>
<p>分支合并时，如果两个分支修改了同一个文件，可能会存在文件合并冲突，在这种情况下，Git不能使用“快速合并”，会提示需要解决冲突才可以合并。</p>
<p>我们新建一个分支，尝试一下。</p>
<p>首先，新建并切换至新的分支<code>brconflict</code>，并在该分支下修改“gitversion.txt”文件的最后一行内容，并提交（最后一行结尾处增加“modify by brconflict”）。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git switch -c brconflict
Switched to a new branch <span style="color:#e6db74">&#39;brconflict&#39;</span>

$ git branch
* brconflict
  master

$ vi gitversion.txt
Git tracks changes of files 2nd modify by brconflict.

$ cat gitversion.txt
1st version. 2nd version. 3th version.
Git has a mutable index called stage.
Git tracks changes.
Git tracks changes of files 2nd modify by brconflict.

$ git add gitversion.txt

$ git commit -m <span style="color:#e6db74">&#34;Git learn: git merge brconflict&#34;</span>
<span style="color:#f92672">[</span>brconflict 1ba9b5c<span style="color:#f92672">]</span> Git learn: git merge brconflict
 <span style="color:#ae81ff">1</span> file changed, <span style="color:#ae81ff">1</span> insertion<span style="color:#f92672">(</span>+<span style="color:#f92672">)</span>, <span style="color:#ae81ff">1</span> deletion<span style="color:#f92672">(</span>-<span style="color:#f92672">)</span>
</code></pre></div><p>然后，我们切换回<code>master</code>分支，也修改该文件的最后一行，并提交（最后一行结尾处增加“modify by master”）。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git switch master
Switched to branch <span style="color:#e6db74">&#39;master&#39;</span>

$ git branch
  brconflict
* master

$ cat gitversion.txt
1st version. 2nd version. 3th version.
Git has a mutable index called stage.
Git tracks changes.
Git tracks changes of files 2nd.

$ vi gitversion.txt
Git tracks changes of files 2nd modify by master.

$ cat gitversion.txt
1st version. 2nd version. 3th version.
Git has a mutable index called stage.
Git tracks changes.
Git tracks changes of files 2nd modify by master.

$ git add gitversion.txt

$ git commit -m <span style="color:#e6db74">&#34;Git learn: git merge master&#34;</span>
<span style="color:#f92672">[</span>master 1f0e9a1<span style="color:#f92672">]</span> Git learn: git merge master
 <span style="color:#ae81ff">1</span> file changed, <span style="color:#ae81ff">1</span> insertion<span style="color:#f92672">(</span>+<span style="color:#f92672">)</span>, <span style="color:#ae81ff">1</span> deletion<span style="color:#f92672">(</span>-<span style="color:#f92672">)</span>
</code></pre></div><p>现在，<code>brconflict</code>分支和<code>master</code>分支都有了各自提交的内容，就像下图这样了。</p>
<p><img src="https://gitee.com/liujixia0410/picbed/raw/master/gitlearn/git_conflict.png" alt="git_conflict"></p>
<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git merge brconflict
Auto-merging git_learn_notes/gitversion.txt
CONFLICT <span style="color:#f92672">(</span>content<span style="color:#f92672">)</span>: Merge conflict in git_learn_notes/gitversion.txt
Automatic merge failed; fix conflicts and <span style="color:#66d9ef">then</span> commit the result.
</code></pre></div><p>果然冲突了<code>Automatic merge failed; fix conflicts and then commit the result.</code>！</p>
<p>Git告诉我们，文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git status
On branch master
You have unmerged paths.
  <span style="color:#f92672">(</span>fix conflicts and run <span style="color:#e6db74">&#34;git commit&#34;</span><span style="color:#f92672">)</span>
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git merge --abort&#34;</span> to abort the merge<span style="color:#f92672">)</span>

Unmerged paths:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add &lt;file&gt;...&#34;</span> to mark resolution<span style="color:#f92672">)</span>
        both modified:   gitversion.txt

no changes added to commit <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add&#34;</span> and/or <span style="color:#e6db74">&#34;git commit -a&#34;</span><span style="color:#f92672">)</span>
</code></pre></div><p>在这种情况下，我们可以直接查看“gitversion.txt”文件，能够看到冲突的具体内容。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat gitversion.txt
1st version. 2nd version. 3th version.
Git has a mutable index called stage.
Git tracks changes.
<span style="color:#f92672">&lt;&lt;&lt;&lt;&lt;&lt;</span>&lt; HEAD
Git tracks changes of files 2nd modify by master.
<span style="color:#f92672">=======</span>
Git tracks changes of files 2nd modify by brconflict.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; brconflict
</code></pre></div><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们可以直接通过 <em><strong><code>vi</code></strong></em> 进行修改，也就是手工解决冲突，修改后就可以正常提交了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ vi gitversion.txt
Git tracks changes of files 2nd modify by master and brconflict.

$ git add gitversion.txt

$ git commit -m <span style="color:#e6db74">&#34;Git learn: fix conflict&#34;</span>
<span style="color:#f92672">[</span>master 7f87757<span style="color:#f92672">]</span> Git learn: fix conflict

$ git status
On branch master
nothing to commit, working tree clean
</code></pre></div><p>至此，<code>brconflict</code>分支和<code>master</code>分支的冲突已经被我们手工解决掉了，内容也已经提交到<code>master</code>分支上，两个分支的关系如下图：</p>
<p><img src="https://gitee.com/liujixia0410/picbed/raw/master/gitlearn/git_fix_conflict.png" alt="git_fix_conflict"></p>
<p>通过带参数的 <em><strong><code>git log --graph</code></strong></em> 可以看到日志对于分支合并的记录情况。之后删除 <code>brconflict</code> 分支即可，工作完成。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git log --graph --pretty<span style="color:#f92672">=</span>oneline --abbrev-commit
*   7f87757 <span style="color:#f92672">(</span>HEAD -&gt; master<span style="color:#f92672">)</span> Git learn: fix conflict
|<span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>| * 1ba9b5c <span style="color:#f92672">(</span>brconflict<span style="color:#f92672">)</span> Git learn: git merge brconflict
* | 1f0e9a1 Git learn: git merge master
|/
* a9e4065 Git learn: gitee
* <span style="color:#ae81ff">9054985</span> Delete git_learn_notes/image directory
......

$ git branch -d brconflict
Deleted branch brconflict <span style="color:#f92672">(</span>was 1ba9b5c<span style="color:#f92672">)</span>.

$ git branch
* master
</code></pre></div><h3 id="53-分支策略-git-merge---no-ff">5.3 分支策略 git merge &ndash;no-ff</h3>
<p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<p>我们具体操作一下，禁用 <code>Fast forward</code> 模式，是在 <em><strong><code>git merge</code></strong></em> 的时候加上参数 <em><strong><code>--no-ff</code></strong></em> 。</p>
<p>首先，仍然创建并切换 <code>brnoff</code> 分支：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git switch -c brnoff
Switched to a new branch <span style="color:#e6db74">&#39;brnoff&#39;</span>

$ git branch
* brnoff
  master
</code></pre></div><p>修改&quot;gitversion.txt&quot;文件（增加一行&quot;Git merge no fast forward.&quot;），并提交一个新的commit。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git switch -c brnoff
Switched to a new branch <span style="color:#e6db74">&#39;brnoff&#39;</span>

$ git branch
* brnoff
  master

$ vi gitversion.txt
Git merge no fast forward.

$ cat gitversion.txt
1st version. 2nd version. 3th version.
Git has a mutable index called stage.
Git tracks changes.
Git tracks changes of files 2nd modify by master and brconflict.
Git merge no fast forward.

$ git add gitversion.txt

$ git commit -m <span style="color:#e6db74">&#34;Git learn: add merge no ff&#34;</span>
<span style="color:#f92672">[</span>brnoff b52772d<span style="color:#f92672">]</span> Git learn: add merge no ff
 <span style="color:#ae81ff">1</span> file changed, <span style="color:#ae81ff">1</span> insertion<span style="color:#f92672">(</span>+<span style="color:#f92672">)</span>
</code></pre></div><p>然后，我们切换回 <code>master</code> 分支，通过 <em><strong><code>--no-ff</code></strong></em> 参数合并 <code>brnoff</code> 分支。</p>
<p>因为本次合并要创建一个新的commit，所以加上 <em><strong><code>-m</code></strong></em> 参数，把commit描述写进去。</p>
<pre><code>$ git switch master
Switched to branch 'master'

$ git branch
  brnoff
* master

$ git merge --no-ff -m &quot;Git learn: merge with --no-ff parameter&quot; brnoff
Merge made by the 'recursive' strategy.
 git_learn_notes/gitversion.txt | 1 +
 1 file changed, 1 insertion(+)
</code></pre><p>合并后，我们用 <em><strong><code>git log --graph</code></strong></em> 看看分支历史，不使用<code>Fast forward</code>模式，merge后就像这样。</p>
<pre><code>$ git log --graph --pretty=oneline --abbrev-commit
*   6944519 (HEAD -&gt; master) Git learn: merge with --no-ff parameter
|\
| * b52772d (brnoff) Git learn: add merge no ff
|/
*   7f87757 Git learn: fix conflict
|\
| * 1ba9b5c Git learn: git merge brconflict
* | 1f0e9a1 Git learn: git merge master
|/
* a9e4065 Git learn: gitee
* 9054985 Delete git_learn_notes/image directory
* cdd0ce7 Upload by PicGo
......
</code></pre><ul>
<li><!-- raw HTML omitted --><strong>分支策略说明</strong><!-- raw HTML omitted --></li>
</ul>
<p><!-- raw HTML omitted -->在实际开发中，我们应该按照几个基本原则进行分支管理：<!-- raw HTML omitted --></p>
<p><!-- raw HTML omitted -->1、<code>master</code> 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；<!-- raw HTML omitted --></p>
<p><!-- raw HTML omitted -->2、干活都在 <code>dev</code> 分支上，也就是说 <code>dev</code> 分支是不稳定的，在版本发布时，再把 <code>dev</code> 分支合并到 <code>master</code> 上，在 <code>master</code> 分支发布1.0版本；<!-- raw HTML omitted --></p>
<p><!-- raw HTML omitted -->3、团队每个人都在 <code>dev</code> 分支上干活，每个人都应该有一个自己的分支，比如 <code>devfrank</code>、<code>devtony</code> 等，时不时地往 <code>dev</code> 分支上合并就可以了。<!-- raw HTML omitted --></p>
<p><!-- raw HTML omitted -->所以，团队合作的分支看起来就像这样：<!-- raw HTML omitted --></p>
<p><img src="https://gitee.com/liujixia0410/picbed/raw/master/gitlearn/git_branch_strategy.png" alt="git_branch_strategy"></p>
<h3 id="54-bug分支管理">5.4 bug分支管理</h3>
<h4 id="541-通过bug分支修复缺陷-git-stash">5.4.1 通过bug分支修复缺陷 git stash</h4>
<p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，分支的强大管理应用，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>比如，现在有一个新的bug需要修复，bug代号001。我们创建一个分支 <code>issue-101</code> 来修复它，但是，等等，当前正在 <code>brdev</code> 上进行的工作还没有提交。</p>
<p>首先，master内容如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat gitversion.txt
This is a gitversion.txt <span style="color:#66d9ef">for</span> learngit.
</code></pre></div><p><code>brdev</code> 分支上已进行的、还未提交的工作内容，如下（通过 <em><strong><code>git status</code></strong></em> 也可以看到这两个未提交的文件状态）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat gittest.txt
This is a new file.

$ cat gitversion.txt
This is a gitversion.txt <span style="color:#66d9ef">for</span> learngit.
Branch brdev<span style="color:#960050;background-color:#1e0010">&#39;</span>s modify.......

$ git status
On branch brdev
Changes to be committed:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git restore --staged &lt;file&gt;...&#34;</span> to unstage<span style="color:#f92672">)</span>
        new file:   gittest.txt

Changes not staged <span style="color:#66d9ef">for</span> commit:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add &lt;file&gt;...&#34;</span> to update what will be committed<span style="color:#f92672">)</span>
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git restore &lt;file&gt;...&#34;</span> to discard changes in working directory<span style="color:#f92672">)</span>
        modified:   gitversion.txt
</code></pre></div><p>根据以上对比，可以看到，<code>brdev</code> 分支比 <code>master</code> 分支多了一个&quot;gittest.txt&quot;文件，以及&quot;gitversion.txt&quot;比 <code>master</code> 分支多了一行&quot;Branch brdev&rsquo;s modify&hellip;..&quot;，很明显，<code>brdev</code> 分支还没完成工作，暂时还不能提交。</p>
<p>但是 <code>master</code> 分支的缺陷修改不能等，必须马上修改，怎么办？</p>
<p>Git的强大也再次体现，Git提供了一个 <em><strong><code>git stash</code></strong></em> 功能，可以把当前工作现场<!-- raw HTML omitted --><strong>保存</strong><!-- raw HTML omitted -->起来，等以后恢复现场后继续工作。</p>
<p>并且用 <em><strong><code>git status</code></strong></em> 查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git stash
Saved working directory and index state WIP on brdev: 4615a5f Git learn: rewirte gitversion.txt

$ git branch
* brdev
  master

$ git status
On branch brdev
nothing to commit, working tree clean
</code></pre></div><p>现在我们开始修改 <code>master</code> 分支上的bug。</p>
<p>首先，创建bug修复的分支，要修复哪个分支的bug，就在哪个分支上创建新的bug修复分支。这里我们通过 <code>master</code> 分支创建一个 <code>brissue-001</code> 的分支。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git switch master
Switched to branch <span style="color:#e6db74">&#39;master&#39;</span>

$ git switch -c brissue-001
Switched to a new branch <span style="color:#e6db74">&#39;brissue-001&#39;</span>

$ git branch
  brdev
* brissue-001
  master
</code></pre></div><p>现在我们已经创建了 <code>brissue-001</code> 分支，并且切换到该分支，开始修复bug，把&quot;This is a gitversion.txt for learngit.&ldquo;改为&quot;This is a gitversion.txt.&quot;，并完成提交。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat gitversion.txt
This is a gitversion.txt <span style="color:#66d9ef">for</span> learngit.

$ vi gitversion.txt
This is a gitversion.txt.

$ git status
On branch brissue-001
Changes not staged <span style="color:#66d9ef">for</span> commit:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add &lt;file&gt;...&#34;</span> to update what will be committed<span style="color:#f92672">)</span>
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git restore &lt;file&gt;...&#34;</span> to discard changes in working directory<span style="color:#f92672">)</span>
        modified:   gitversion.txt

no changes added to commit <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add&#34;</span> and/or <span style="color:#e6db74">&#34;git commit -a&#34;</span><span style="color:#f92672">)</span>

$ git add gitversion.txt

$ git commit -m <span style="color:#e6db74">&#34;Git learn: fix issue-001&#34;</span>
<span style="color:#f92672">[</span>brissue-001 10baade<span style="color:#f92672">]</span> Git learn: fix issue-001
 <span style="color:#ae81ff">1</span> file changed, <span style="color:#ae81ff">1</span> insertion<span style="color:#f92672">(</span>+<span style="color:#f92672">)</span>, <span style="color:#ae81ff">1</span> deletion<span style="color:#f92672">(</span>-<span style="color:#f92672">)</span>
</code></pre></div><p>修复完成后，切换到 <code>master</code> 分支，完成合并，删除 <code>brissue-001</code> 分支。如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git switch master
Switched to branch <span style="color:#e6db74">&#39;master&#39;</span>

$ git branch
  brdev
  brissue-001
* master

$ git merge --no-ff -m <span style="color:#e6db74">&#34;Git learn: merged fix issue-001&#34;</span> brissue-001
Merge made by the <span style="color:#e6db74">&#39;recursive&#39;</span> strategy.
 git_learn_notes/gitversion.txt | <span style="color:#ae81ff">2</span> +-
 <span style="color:#ae81ff">1</span> file changed, <span style="color:#ae81ff">1</span> insertion<span style="color:#f92672">(</span>+<span style="color:#f92672">)</span>, <span style="color:#ae81ff">1</span> deletion<span style="color:#f92672">(</span>-<span style="color:#f92672">)</span>

$ git branch -d brissue-001
Deleted branch brissue-001 <span style="color:#f92672">(</span>was 10baade<span style="color:#f92672">)</span>.

$ git branch
  brdev
* master

$ git status
On branch master
nothing to commit, working tree clean
</code></pre></div><p>至此，bug修复工作完成了。</p>
<p>但是，回看工作区，<em><strong><code>git status</code></strong></em> 好干净啊，啥也没有了。我们之前提到的<!-- raw HTML omitted --><strong>保存工作现场</strong><!-- raw HTML omitted -->哪儿去了呢？通过 <em><strong><code>git stash list</code></strong></em> 看一下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git stash list
stash@<span style="color:#f92672">{</span>0<span style="color:#f92672">}</span>: WIP on brdev: 4615a5f Git learn: rewirte gitversion.txt
</code></pre></div><p>我们看到，工作现场确实被保存了起来，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p>
<p>1、用 <em><strong><code>git stash apply</code></strong></em> 恢复，但是恢复后，stash内容并不删除，你需要用 <em><strong><code>git stash drop</code></strong></em> 来删除；</p>
<p>2、用 <em><strong><code>git stash pop</code></strong></em>，恢复的同时把stash内容也删了。</p>
<p>无论用哪种方法，stash内容被删除后，<em><strong><code>git stash list</code></strong></em> 就干净了，什么都没了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git stash pop
On branch brdev
Changes to be committed:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git restore --staged &lt;file&gt;...&#34;</span> to unstage<span style="color:#f92672">)</span>
        new file:   gittest.txt

Changes not staged <span style="color:#66d9ef">for</span> commit:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add &lt;file&gt;...&#34;</span> to update what will be committed<span style="color:#f92672">)</span>
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git restore &lt;file&gt;...&#34;</span> to discard changes in working directory<span style="color:#f92672">)</span>
        modified:   gitversion.txt

Dropped refs/stash@<span style="color:#f92672">{</span>0<span style="color:#f92672">}</span> <span style="color:#f92672">(</span>4615a5fa69b189adfbe8e71d9ddb5604838d1c96<span style="color:#f92672">)</span>

$ git stash list

</code></pre></div><h4 id="542-将master分支的修复merge到其他dev分支-git-cherry-pick">5.4.2 将master分支的修复，merge到其他dev分支 git cherry-pick</h4>
<p>通过以上操作，在 <code>master</code> 分支上修复了bug。但是，<code>brdev</code> 分支是早期从 <code>master</code> 分支分出来的，所以，这个bug其实在当前 <code>brdev</code> 分支上也存在。</p>
<p>那怎么在 <code>brdev</code> 分支上修复同样的bug？重复操作一次，提交？肯定没问题。但是，可不可以不重复操作？可以。</p>
<p>同样的bug，要在 <code>brdev</code> 上修复，我们只需要把 <code>10baade Git learn: fix issue-001</code> 这个提交所做的修改“复制”到 <code>brdev</code> 分支。注意：我们只想复制 <code>10baade Git learn: fix issue-001</code> 这个提交所做的修改，并不是把整个master分支merge过来。</p>
<p>因此，Git专门提供了一个 <em><strong><code>git cherry-pick</code></strong></em> 命令，让我们能复制一个特定的提交到当前分支。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git cherry-pick 10baade
error: your local changes would be overwritten by cherry-pick.
hint: commit your changes or stash them to proceed.
fatal: cherry-pick failed
</code></pre></div><p>我们发现，<em><strong><code>git cherry-pick</code></strong></em> 命令执行报错了。根据提示&quot;hint&quot;可以看到，Git虽然可以将某个提交所做的修改合并进来，但是需要本地先把未commit的内容全部commit之后才可以。</p>
<p>我们把 <code>brdev</code> 分支的内容编写完成之后，先提交，再把 <code>10baade Git learn: fix issue-001</code> 这个提交合并进来，我们试一下。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git cherry-pick 10baade
Auto-merging git_learn_notes/gitversion.txt
CONFLICT <span style="color:#f92672">(</span>content<span style="color:#f92672">)</span>: Merge conflict in git_learn_notes/gitversion.txt
error: could not apply 10baade... Git learn: fix issue-001
hint: after resolving the conflicts, mark the corrected paths
hint: with <span style="color:#e6db74">&#39;git add &lt;paths&gt;&#39;</span> or <span style="color:#e6db74">&#39;git rm &lt;paths&gt;&#39;</span>
hint: and commit the result with <span style="color:#e6db74">&#39;git commit&#39;</span>

$ vi gitversion.txt

$ git add gitversion.txt

$ git commit -m <span style="color:#e6db74">&#34;Git learn: cherry-pick&#34;</span>
<span style="color:#f92672">[</span>brdev d893b6d<span style="color:#f92672">]</span> Git learn: cherry-pick
 Date: Fri Feb <span style="color:#ae81ff">5</span> 14:12:08 <span style="color:#ae81ff">2021</span> +0800
 <span style="color:#ae81ff">1</span> file changed, <span style="color:#ae81ff">1</span> insertion<span style="color:#f92672">(</span>+<span style="color:#f92672">)</span>, <span style="color:#ae81ff">1</span> deletion<span style="color:#f92672">(</span>-<span style="color:#f92672">)</span>
</code></pre></div><p><em><strong><code>git cherry-pick</code></strong></em> 命令给出了一个提示，需要解决冲突，我们按照之前章节提到的方式，<em><strong><code>vi</code></strong></em> 人工解决冲突，然后提交，合并完成。</p>
<p>说明：<em><strong><code>git cherry-pick</code></strong></em> 为什么没能直接自动合并成功，目前未找到原因，以后学习过程中再逐渐明确。</p>
<h3 id="55-feature分支管理">5.5 feature分支管理</h3>
<p>软件开发过程中，经常会有需求变更，经常会随时加入新功能，而且有些功能是具有实验性质的（比如DCE清算7.0一阶段中，把数字类型从BigDecimal改为double，未来是否一定要应用，不确定）。</p>
<p>这类实验性质的功能，任何开发团队都不愿意让其影响主分支。</p>
<p>所以，对于新功能开发，最好新建feature分支，在这上面开发，合并，然后删除分支。</p>
<p>这里，不再做什么操作试验了，没有什么新的命令可学，整个过程就是熟练使用之前章节学到的内容，比如建立和切换分支 <em><strong><code>git switch -c &lt;branchname&gt;</code></strong></em>、合并分支 <em><strong><code>git merge --no-ff</code></strong></em>、删除分支 <em><strong><code>git branch -d &lt;branchname&gt;</code></strong></em> 等操作。</p>
<p>只是在删除分支过程中，可能会出现一种情况，就是某个实验性功能最终决定不要了，白干了，这时候该分支没有经过merge，Git为防止误删除，会给出一个非常明确的提示：分支没有合并，删除失败。并且很明确的告诉我们，如果确定要删除，参数改为 <em><strong><code>-D</code></strong></em> 可以强行删除。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git branch -d feature-double
error: The branch <span style="color:#e6db74">&#39;feature-double&#39;</span> is not fully merged.
If you are sure you want to delete it, run <span style="color:#e6db74">&#39;git branch -D feature-double&#39;</span>.
</code></pre></div><h2 id="六gitee学习">六、Gitee学习</h2>
<p>如果国内访问GitHub比较慢，可以改用Gitee作为远程仓库。</p>
<p>首先我们可以在Gitee上建立一个仓库，可以与本地仓库同名，以便把本地仓库与远程仓库关联起来。</p>
<h3 id="61-gitee仓库建立与ssh公钥">6.1 Gitee仓库建立与SSH公钥</h3>
<h4 id="611-gitee添加ssh公钥">6.1.1 Gitee添加SSH公钥</h4>
<p>注册并登录Gitee，与GitHub一样，先上传自己的SSH公钥。Gitee SSH公钥添加页面截图如下：</p>
<p><img src="https://gitee.com/liujixia0410/picbed/raw/master/gitlearn/Gitee_SSHKey.jpg" alt="Gitee_SSHKey"></p>
<p>本地Git获取SSH公钥，如下：</p>
<p>Gitee 提供了基于SSH协议的Git服务，在使用SSH协议访问仓库仓库之前，需要先配置好账户/仓库的SSH公钥。</p>
<p>你可以按如下命令来生成 sshkey:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ssh-keygen -t rsa -C <span style="color:#e6db74">&#34;xxxx@xxxx.com&#34;</span>  
<span style="color:#75715e"># Generating public/private rsa key pair...</span>
</code></pre></div><blockquote>
<p>注意：这里的 <code>xxxxx@xxxxx.com</code> 只是生成的 sshkey 的名称，并不约束或要求具体命名为某个邮箱。
很多教程均讲解的使用邮箱生成，其一开始的初衷仅仅是为了便于辨识所以使用了邮箱。</p>
</blockquote>
<p>按照提示完成三次回车，即可生成 ssh key。通过查看 <code>~/.ssh/id_rsa.pub</code> 文件内容，获取到自己的 public key。</p>
<pre><code>$ cat /c/Users/lenovo/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxThU= liujixia0410@163.com
</code></pre><blockquote>
<p>以上public key是我个人的，在本文中使用<code>xxxxxxxxxxxxxxxxx</code>隐藏了。</p>
</blockquote>
<p>复制生成后的 ssh key，添加到上面截图显示的公钥文本框内即可。</p>
<h4 id="612-gitee仓库建立并与本地关联">6.1.2 Gitee仓库建立并与本地关联</h4>
<p><img src="https://gitee.com/liujixia0410/picbed/raw/master/gitlearn/Gitee_create_repo.png" alt="Gitee_create_repo"></p>
<p>然后，我们在本地库使用命令 <em><strong><code>git remote add</code></strong></em> 把本地库与Gitee远程库关联起来。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git remote add origin git@gitee.com:liujixia0410/learngit.git
fatal: remote origin already exists.
</code></pre></div><p>我们发现，执行错误，原因是之前我们本地的git仓库已经与GitHub建立了远程关联，名字也叫origin。我们通过 <em><strong><code>git remote -v</code></strong></em> 查看一下，然后可以删除这个远程库，再重新关联。</p>
<pre><code>$ git remote -v
origin  git@github.com:liujixia0410/learngit.git (fetch)
origin  git@github.com:liujixia0410/learngit.git (push)

$ git remote rm origin

$ git remote add origin git@gitee.com:liujixia0410/learngit.git
</code></pre><p>此时，我们本地库与Gitee远程库已经建立了关联，可以继续使用 <em><strong><code>git push</code></strong></em> 进行上传推送了。</p>
<h2 id="附录">附录</h2>
<h3 id="qa">Q&amp;A</h3>
<ul>
<li><em><strong>不在Git仓库管理目录内执行</strong></em>
<ul>
<li>Q：输入<strong>git add Git_Learn_Note.md</strong>，得到错误：fatal: not a git repository (or any of the parent directories)。</li>
<li>A：Git命令必须在Git仓库目录内执行（<strong>git init</strong>除外），在仓库目录外执行是没有意义的。</li>
</ul>
</li>
<li><em><strong>文件不存在</strong></em>
<ul>
<li>Q：输入<strong>git add Git_Learn_Note.md</strong>，得到错误fatal: pathspec &lsquo;Git_Learn_Note.md&rsquo; did not match any files。</li>
<li>A：添加某个文件时，该文件必须在当前目录下存在。</li>
</ul>
</li>
<li><em><strong>git push 报错 Logon failed</strong></em>
<ul>
<li>Q：在推送至GitHub时，报错信息&quot;Logon failed, use ctrl+c to cancel basic credential prompt.&rdquo;</li>
<li>A：连续输入两次账户密码，第一次HTTP协议仍然会报错，第二次会变成OpenSSH协议，就成功了。原因暂未了解。但是如果在GitHub上先建立repo，然后 <em><strong>git clone</strong></em> 到本地，之后本地修改后再 <em><strong>git push</strong></em> 就不会出现这个现象了。</li>
</ul>
</li>
<li><em><strong>git cherry-pick</strong></em> 提示需要手动merge
<ul>
<li>Q：在合并某个特定提交至当前分支时，<em><strong><code>git cherry-pick</code></strong></em> 没有自动完成合并，而是提示conflict，需要手工解决冲突。</li>
<li>A：暂未研究明白如何能自动合并成功，未来学习过程中再研究。</li>
</ul>
</li>
<li>d</li>
</ul>
<h3 id="git命令列表">Git命令列表</h3>
<table>
<thead>
<tr>
<th>Commond</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git add [file_name]</td>
<td>添加一个文件到Git，无论是新文件还是修改文件，都需要通过add之后，才能commit</td>
</tr>
<tr>
<td>git commit</td>
<td>将git add之后的文件，全部提交，并产生新的commit_id<!-- raw HTML omitted -->-m &ldquo;[comment]&quot;：提交时，添加日志<!-- raw HTML omitted -->-a [file_name]：讲一个没有add的文件，同时执行add和commit</td>
</tr>
<tr>
<td>git status</td>
<td>查看Git所管理的文件状态，包括哪些没有add，哪些add没有提交，哪些是新建文件，哪些是修改文件等</td>
</tr>
<tr>
<td>git diff</td>
<td>查看当前修改与Git当前版本之间的差异</td>
</tr>
<tr>
<td>git log</td>
<td>查看Git管理下的所有日志<!-- raw HTML omitted -->&ndash;pretty=oneline：该参数简化log显示为同一行，方便查看<!-- raw HTML omitted -->&ndash;graph：查看分支合并日志图<!-- raw HTML omitted --><em><strong><code>git log --graph --pretty=oneline --abbrev-commit</code></strong></em></td>
</tr>
<tr>
<td>git reset [commit_id]</td>
<td>版本回退</td>
</tr>
<tr>
<td>git reflog</td>
<td>查看Git管理下所有被记录的操作</td>
</tr>
<tr>
<td>git restore</td>
<td>撤销修改，分为以下两种情况<!-- raw HTML omitted -->git restore &lt;filename&gt;：git add之前，撤销工作区的修改<!-- raw HTML omitted -->git restore &ndash;stage &lt;filename&gt;：git add之后，撤销暂存区的修改</td>
</tr>
<tr>
<td>git rm</td>
<td>删除文件</td>
</tr>
<tr>
<td>git remove</td>
<td>git remote add：将本地版本库关联远程版本库<!-- raw HTML omitted -->git remote -v：查看本地库关联的远程库<!-- raw HTML omitted -->git remote rm：删除本地库与远程库的关联</td>
</tr>
<tr>
<td>git push</td>
<td>将本地版本库已经提交的内容推送到远程版本库<!-- raw HTML omitted -->首次推送增加-u参数</td>
</tr>
<tr>
<td>git branch</td>
<td>git branch：查看分支，当前分支前面是*<!-- raw HTML omitted -->git branch &lt;branchname&gt;： 创建分支<!-- raw HTML omitted -->git branch -d &lt;branchname&gt;：删除分支（未合并分支Git会提示不让删除，改为<code>-D</code>，强行删除）</td>
</tr>
<tr>
<td>git checkout</td>
<td>git checkout &ndash; &lt;filename&gt;：老版本Git，撤销修改<!-- raw HTML omitted -->git checkout &lt;branchname&gt;：切换分支<!-- raw HTML omitted -->git checkout -b &lt;branchname&gt;：创建并切换分支</td>
</tr>
<tr>
<td>git switch</td>
<td>git switch &lt;branchname&gt;：切换分支<!-- raw HTML omitted -->git switch -c &lt;branchname&gt;：创建并切换分支</td>
</tr>
<tr>
<td>git merge</td>
<td>git merge &lt;branchname&gt;：合并指定分支到当前分支<!-- raw HTML omitted -->&ndash;no-ff：合并分支时不允许 <code>fast forward</code> 模式，强行手动合并，并且体现commit日志<!-- raw HTML omitted --><em><strong><code>git merge --no-ff -m &quot;commit日志内容&quot; &lt;branchname&gt;</code></strong></em></td>
</tr>
<tr>
<td>git stash</td>
<td>git stash：保存工作现场，便于bug修复分支之后恢复dev分支内容<!-- raw HTML omitted -->git stash list：查看已经保存的工作现场列表<!-- raw HTML omitted -->git stash pop：恢复被stash的工作现场，并删除stash内容<!-- raw HTML omitted -->git stash apply &lt;stashid&gt;：恢复被stash的工作现场，但不删除stash内容<!-- raw HTML omitted -->git stash drop &lt;stashid&gt;：删除stash内容</td>
</tr>
<tr>
<td>git cherry-pick</td>
<td>git cherry-pick &lt;logid&gt;：复制某个特定提交到当前分支</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</p>
          <p>27 May 2021
            
          </p>
          
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col s3 m1">
      
        <a class="btn-floating btn-large waves-effect waves-light" href="http://example.org/post/nexus/"><i class="mdi-navigation-arrow-back"></i></a>
      
      </div>
      <div class="col s6 m10 center">&nbsp</div>
      <div class="col s3 m1">
      
        <a class="btn-floating btn-large disabled"><i class="mdi-navigation-arrow-forward"></i></a>
      
      </div>
    </div>

  </div>
</div>

  <footer class="page-footer">
    <div class="footer-copyright">
      <div class="container">
      
      <div class="right">Design <a class="grey-text text-lighten-4" href="http://pdevty.github.io/blog/">pdevty</a></div>
      </div>
    </div>
  </footer>
  <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
  <script src="http://example.org//js/materialize.min.js"></script>
  <script src="http://example.org//js/init.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  

  </body>
</html>

